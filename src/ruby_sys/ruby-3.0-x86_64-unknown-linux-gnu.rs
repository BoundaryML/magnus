/* automatically generated by rust-bindgen 0.59.2 */

pub const RUBY_H: u32 = 1;
pub const HAVE_RUBY_ATOMIC_H: u32 = 1;
pub const HAVE_RUBY_DEBUG_H: u32 = 1;
pub const HAVE_RUBY_DEFINES_H: u32 = 1;
pub const HAVE_RUBY_ENCODING_H: u32 = 1;
pub const HAVE_RUBY_INTERN_H: u32 = 1;
pub const HAVE_RUBY_IO_H: u32 = 1;
pub const HAVE_RUBY_MEMORY_VIEW_H: u32 = 1;
pub const HAVE_RUBY_MISSING_H: u32 = 1;
pub const HAVE_RUBY_ONIGMO_H: u32 = 1;
pub const HAVE_RUBY_ONIGURUMA_H: u32 = 1;
pub const HAVE_RUBY_RACTOR_H: u32 = 1;
pub const HAVE_RUBY_RANDOM_H: u32 = 1;
pub const HAVE_RUBY_RE_H: u32 = 1;
pub const HAVE_RUBY_REGEX_H: u32 = 1;
pub const HAVE_RUBY_RUBY_H: u32 = 1;
pub const HAVE_RUBY_ST_H: u32 = 1;
pub const HAVE_RUBY_THREAD_H: u32 = 1;
pub const HAVE_RUBY_THREAD_NATIVE_H: u32 = 1;
pub const HAVE_RUBY_UTIL_H: u32 = 1;
pub const HAVE_RUBY_VERSION_H: u32 = 1;
pub const HAVE_RUBY_VM_H: u32 = 1;
pub const RUBY_RUBY_H: u32 = 1;
pub const INCLUDE_RUBY_CONFIG_H: u32 = 1;
pub const RUBY_PLATFORM: &[u8; 13usize] = b"x86_64-linux\0";
pub const RUBY_DEFINES_H: u32 = 1;
pub const RBIMPL_RUBY_DEBUG: u32 = 0;
pub const RUBY_DEBUG: u32 = 0;
pub const RUBY_NDEBUG: u32 = 1;
pub const RUBY_MISSING_H: u32 = 1;
pub const RUBY_ST_H: u32 = 1;
pub const RUBY_UNTYPED_DATA_WARNING: u32 = 0;
pub const RUBY_RUBY_BACKWARD_H: u32 = 1;
pub const RUBY_EVENT_NONE: u32 = 0;
pub const RUBY_EVENT_LINE: u32 = 1;
pub const RUBY_EVENT_CLASS: u32 = 2;
pub const RUBY_EVENT_END: u32 = 4;
pub const RUBY_EVENT_CALL: u32 = 8;
pub const RUBY_EVENT_RETURN: u32 = 16;
pub const RUBY_EVENT_C_CALL: u32 = 32;
pub const RUBY_EVENT_C_RETURN: u32 = 64;
pub const RUBY_EVENT_RAISE: u32 = 128;
pub const RUBY_EVENT_ALL: u32 = 255;
pub const RUBY_EVENT_B_CALL: u32 = 256;
pub const RUBY_EVENT_B_RETURN: u32 = 512;
pub const RUBY_EVENT_THREAD_BEGIN: u32 = 1024;
pub const RUBY_EVENT_THREAD_END: u32 = 2048;
pub const RUBY_EVENT_FIBER_SWITCH: u32 = 4096;
pub const RUBY_EVENT_SCRIPT_COMPILED: u32 = 8192;
pub const RUBY_EVENT_TRACEPOINT_ALL: u32 = 65535;
pub const RUBY_EVENT_RESERVED_FOR_INTERNAL_USE: u32 = 196608;
pub const RUBY_INTERNAL_EVENT_SWITCH: u32 = 262144;
pub const RUBY_EVENT_SWITCH: u32 = 262144;
pub const RUBY_INTERNAL_EVENT_NEWOBJ: u32 = 1048576;
pub const RUBY_INTERNAL_EVENT_FREEOBJ: u32 = 2097152;
pub const RUBY_INTERNAL_EVENT_GC_START: u32 = 4194304;
pub const RUBY_INTERNAL_EVENT_GC_END_MARK: u32 = 8388608;
pub const RUBY_INTERNAL_EVENT_GC_END_SWEEP: u32 = 16777216;
pub const RUBY_INTERNAL_EVENT_GC_ENTER: u32 = 33554432;
pub const RUBY_INTERNAL_EVENT_GC_EXIT: u32 = 67108864;
pub const RUBY_INTERNAL_EVENT_OBJSPACE_MASK: u32 = 133169152;
pub const RUBY_INTERNAL_EVENT_MASK: u32 = 4294901760;
pub const RUBY_INTEGER_UNIFICATION: u32 = 1;
pub const RUBY_BLOCK_CALL_FUNC_TAKES_BLOCKARG: u32 = 1;
pub const RUBY_ALLOCV_LIMIT: u32 = 1024;
pub const RUBY_PRI_VALUE_MARK: &[u8; 2usize] = b"\x0B\0";
pub const RUBY_INTERN_H: u32 = 1;
pub const RUBY_VM: u32 = 1;
pub const RUBY_SUBST_H: u32 = 1;
pub const RUBY_ENCODING_H: u32 = 1;
pub type va_list = __builtin_va_list;
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __pid_t = ::std::os::raw::c_int;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type ssize_t = __ssize_t;
pub type mode_t = __mode_t;
pub type pid_t = __pid_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
extern "C" {
    pub fn ruby_xmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xmalloc2(nelems: size_t, elemsiz: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xcalloc(nelems: size_t, elemsiz: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xrealloc(
        ptr: *mut ::std::os::raw::c_void,
        newsiz: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xrealloc2(
        ptr: *mut ::std::os::raw::c_void,
        newelems: size_t,
        newsiz: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rb_assert_failure(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
pub type VALUE = ::std::os::raw::c_ulong;
pub type ID = ::std::os::raw::c_ulong;
extern "C" {
    pub fn rb_class_new(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_singleton_class_clone(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_singleton_class_attached(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_check_inheritable(arg1: VALUE);
}
extern "C" {
    pub fn rb_define_class_id(arg1: ID, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_define_class_id_under(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_module_new() -> VALUE;
}
extern "C" {
    pub fn rb_define_module_id(arg1: ID) -> VALUE;
}
extern "C" {
    pub fn rb_define_module_id_under(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_mod_included_modules(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_include_p(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_ancestors(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_instance_methods(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_public_instance_methods(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_protected_instance_methods(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_private_instance_methods(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_obj_singleton_methods(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_define_method_id(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_undef(arg1: VALUE, arg2: ID);
}
extern "C" {
    pub fn rb_define_protected_method(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_private_method(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_singleton_method(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_singleton_class(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_sourceline() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_sourcefile() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_check_funcall(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_check_funcall_kw(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_remove_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_remove_method_id(arg1: VALUE, arg2: ID);
}
extern "C" {
    pub fn rb_eval_cmd_kw(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_apply(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_instance_eval(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_obj_instance_exec(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_module_eval(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_module_exec(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
pub type rb_alloc_func_t = ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>;
extern "C" {
    pub fn rb_define_alloc_func(arg1: VALUE, arg2: rb_alloc_func_t);
}
extern "C" {
    pub fn rb_undef_alloc_func(arg1: VALUE);
}
extern "C" {
    pub fn rb_get_alloc_func(arg1: VALUE) -> rb_alloc_func_t;
}
extern "C" {
    pub fn rb_clear_constant_cache();
}
extern "C" {
    pub fn rb_clear_method_cache_by_class(arg1: VALUE);
}
extern "C" {
    pub fn rb_alias(arg1: VALUE, arg2: ID, arg3: ID);
}
extern "C" {
    pub fn rb_attr(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_method_boundp(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_method_basic_definition_p(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_obj_respond_to(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_respond_to(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_f_notimplement(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        obj: VALUE,
        marker: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_backtrace();
}
extern "C" {
    pub fn rb_make_backtrace() -> VALUE;
}
extern "C" {
    pub fn rb_define_method(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_module_function(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_global_function(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_undef_method(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_define_alias(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_define_attr(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_6 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_7 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_8 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_9 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_10 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_11 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_12 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
extern "C" {
    pub fn rb_int2big(i: isize) -> VALUE;
}
extern "C" {
    pub fn rb_int2inum(i: isize) -> VALUE;
}
extern "C" {
    pub fn rb_uint2big(i: usize) -> VALUE;
}
extern "C" {
    pub fn rb_uint2inum(i: usize) -> VALUE;
}
impl ruby_special_consts {
    pub const RUBY_SPECIAL_SHIFT: ruby_special_consts = ruby_special_consts::RUBY_Qnil;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_special_consts {
    RUBY_Qfalse = 0,
    RUBY_Qtrue = 20,
    RUBY_Qnil = 8,
    RUBY_Qundef = 52,
    RUBY_IMMEDIATE_MASK = 7,
    RUBY_FIXNUM_FLAG = 1,
    RUBY_FLONUM_MASK = 3,
    RUBY_FLONUM_FLAG = 2,
    RUBY_SYMBOL_FLAG = 12,
}
extern "C" {
    pub fn rb_out_of_int(num: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_num2long(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_num2ulong(num: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_num2int(arg1: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_fix2int(arg1: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_num2uint(arg1: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_fix2uint(arg1: VALUE) -> ::std::os::raw::c_ulong;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rvalue_flags {
    RVALUE_EMBED_LEN_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
extern "C" {
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_value_type {
    RUBY_T_NONE = 0,
    RUBY_T_OBJECT = 1,
    RUBY_T_CLASS = 2,
    RUBY_T_MODULE = 3,
    RUBY_T_FLOAT = 4,
    RUBY_T_STRING = 5,
    RUBY_T_REGEXP = 6,
    RUBY_T_ARRAY = 7,
    RUBY_T_HASH = 8,
    RUBY_T_STRUCT = 9,
    RUBY_T_BIGNUM = 10,
    RUBY_T_FILE = 11,
    RUBY_T_DATA = 12,
    RUBY_T_MATCH = 13,
    RUBY_T_COMPLEX = 14,
    RUBY_T_RATIONAL = 15,
    RUBY_T_NIL = 17,
    RUBY_T_TRUE = 18,
    RUBY_T_FALSE = 19,
    RUBY_T_SYMBOL = 20,
    RUBY_T_FIXNUM = 21,
    RUBY_T_UNDEF = 22,
    RUBY_T_IMEMO = 26,
    RUBY_T_NODE = 27,
    RUBY_T_ICLASS = 28,
    RUBY_T_ZOMBIE = 29,
    RUBY_T_MOVED = 30,
    RUBY_T_MASK = 31,
}
extern "C" {
    pub fn rb_check_type(obj: VALUE, t: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_fl_ushift {
    RUBY_FL_USHIFT = 12,
}
impl ruby_fl_type {
    pub const RUBY_FL_PROMOTED0: ruby_fl_type = ruby_fl_type::RUBY_FL_WB_PROTECTED;
}
impl ruby_fl_type {
    pub const RUBY_FL_SHAREABLE: ruby_fl_type = ruby_fl_type::RUBY_FL_TAINT;
}
impl ruby_fl_type {
    pub const RUBY_FL_UNTRUSTED: ruby_fl_type = ruby_fl_type::RUBY_FL_TAINT;
}
impl ruby_fl_type {
    pub const RUBY_ELTS_SHARED: ruby_fl_type = ruby_fl_type::RUBY_FL_USER2;
}
impl ruby_fl_type {
    pub const RUBY_FL_SINGLETON: ruby_fl_type = ruby_fl_type::RUBY_FL_USER0;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_fl_type {
    RUBY_FL_WB_PROTECTED = 32,
    RUBY_FL_PROMOTED1 = 64,
    RUBY_FL_PROMOTED = 96,
    RUBY_FL_FINALIZE = 128,
    RUBY_FL_TAINT = 256,
    RUBY_FL_SEEN_OBJ_ID = 512,
    RUBY_FL_EXIVAR = 1024,
    RUBY_FL_FREEZE = 2048,
    RUBY_FL_USER0 = 4096,
    RUBY_FL_USER1 = 8192,
    RUBY_FL_USER2 = 16384,
    RUBY_FL_USER3 = 32768,
    RUBY_FL_USER4 = 65536,
    RUBY_FL_USER5 = 131072,
    RUBY_FL_USER6 = 262144,
    RUBY_FL_USER7 = 524288,
    RUBY_FL_USER8 = 1048576,
    RUBY_FL_USER9 = 2097152,
    RUBY_FL_USER10 = 4194304,
    RUBY_FL_USER11 = 8388608,
    RUBY_FL_USER12 = 16777216,
    RUBY_FL_USER13 = 33554432,
    RUBY_FL_USER14 = 67108864,
    RUBY_FL_USER15 = 134217728,
    RUBY_FL_USER16 = 268435456,
    RUBY_FL_USER17 = 536870912,
    RUBY_FL_USER18 = 1073741824,
    RUBY_FL_USER19 = -2147483648,
}
pub const RUBY_FL_DUPPED: _bindgen_ty_13 = _bindgen_ty_13::RUBY_FL_DUPPED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_13 {
    RUBY_FL_DUPPED = 1311,
}
extern "C" {
    pub fn rb_obj_infect(victim: VALUE, carrier: VALUE);
}
extern "C" {
    pub fn rb_freeze_singleton_class(klass: VALUE);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rstring_flags {
    RSTRING_NOEMBED = 8192,
    RSTRING_EMBED_LEN_MASK = 507904,
    RSTRING_FSTR = 536870912,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rstring_consts {
    RSTRING_EMBED_LEN_SHIFT = 14,
    RSTRING_EMBED_LEN_MAX = 23,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString {
    pub basic: RBasic,
    pub as_: RString__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1 {
    pub heap: RString__bindgen_ty_1__bindgen_ty_1,
    pub ary: [::std::os::raw::c_char; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared: VALUE,
}
extern "C" {
    pub fn rb_str_to_str(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_string_value(arg1: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_string_value_ptr(arg1: *mut VALUE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_string_value_cstr(arg1: *mut VALUE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_str_export(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_export_locale(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_safe_str(arg1: VALUE);
}
extern "C" {
    pub fn rb_num2dbl(arg1: VALUE) -> f64;
}
extern "C" {
    pub fn rb_float_value(arg1: VALUE) -> f64;
}
extern "C" {
    pub fn rb_float_new(arg1: f64) -> VALUE;
}
extern "C" {
    pub fn rb_float_new_in_heap(arg1: f64) -> VALUE;
}
extern "C" {
    pub fn rb_ll2inum(arg1: ::std::os::raw::c_longlong) -> VALUE;
}
extern "C" {
    pub fn rb_ull2inum(arg1: ::std::os::raw::c_ulonglong) -> VALUE;
}
extern "C" {
    pub fn rb_num2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn rb_num2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rb_num2short(arg1: VALUE) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn rb_num2ushort(arg1: VALUE) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn rb_fix2short(arg1: VALUE) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn rb_fix2ushort(arg1: VALUE) -> ::std::os::raw::c_ushort;
}
pub type st_data_t = ::std::os::raw::c_ulong;
pub type st_index_t = st_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_hash_type {
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int,
    >,
    pub hash: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_index_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table {
    pub entry_power: ::std::os::raw::c_uchar,
    pub bin_power: ::std::os::raw::c_uchar,
    pub size_ind: ::std::os::raw::c_uchar,
    pub rebuilds_num: ::std::os::raw::c_uint,
    pub type_: *const st_hash_type,
    pub num_entries: st_index_t,
    pub bins: *mut st_index_t,
    pub entries_start: st_index_t,
    pub entries_bound: st_index_t,
    pub entries: *mut st_table_entry,
}
extern "C" {
    pub fn rb_st_init_table(arg1: *const st_hash_type) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_table_with_size(arg1: *const st_hash_type, arg2: st_index_t)
        -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_numtable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strtable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strcasetable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_delete(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_delete_safe(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
        arg4: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_shift(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_insert(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_insert2(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: st_data_t,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_data_t>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_lookup(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_get_key(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type st_update_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut st_data_t,
        value: *mut st_data_t,
        arg: st_data_t,
        existing: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_st_update(
        table: *mut st_table,
        key: st_data_t,
        func: st_update_callback_func,
        arg: st_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type st_foreach_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: st_data_t,
        arg2: st_data_t,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int,
>;
pub type st_foreach_check_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: st_data_t,
        arg2: st_data_t,
        arg3: st_data_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_st_foreach_with_replace(
        tab: *mut st_table,
        func: st_foreach_check_callback_func,
        replace: st_update_callback_func,
        arg: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_foreach(
        arg1: *mut st_table,
        arg2: st_foreach_callback_func,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_foreach_check(
        arg1: *mut st_table,
        arg2: st_foreach_check_callback_func,
        arg3: st_data_t,
        arg4: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_keys(table: *mut st_table, keys: *mut st_data_t, size: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_keys_check(
        table: *mut st_table,
        keys: *mut st_data_t,
        size: st_index_t,
        never: st_data_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_values(
        table: *mut st_table,
        values: *mut st_data_t,
        size: st_index_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_values_check(
        table: *mut st_table,
        values: *mut st_data_t,
        size: st_index_t,
        never: st_data_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_add_direct(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t);
}
extern "C" {
    pub fn rb_st_free_table(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t);
}
extern "C" {
    pub fn rb_st_clear(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_st_copy(arg1: *mut st_table) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_numcmp(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_numhash(arg1: st_data_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_locale_insensitive_strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_locale_insensitive_strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_memsize(arg1: *const st_table) -> size_t;
}
extern "C" {
    pub fn rb_st_hash(ptr: *const ::std::os::raw::c_void, len: size_t, h: st_index_t)
        -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_uint32(h: st_index_t, i: u32) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_end(h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_start(h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_bulk_insert_into_st_table(
        arg1: ::std::os::raw::c_long,
        arg2: *const VALUE,
        arg3: VALUE,
    );
}
extern "C" {
    pub fn rb_gc_writebarrier(a: VALUE, b: VALUE);
}
extern "C" {
    pub fn rb_gc_writebarrier_unprotect(obj: VALUE);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rarray_flags {
    RARRAY_EMBED_FLAG = 8192,
    RARRAY_EMBED_LEN_MASK = 98304,
    RARRAY_TRANSIENT_FLAG = 33554432,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rarray_consts {
    RARRAY_EMBED_LEN_SHIFT = 15,
    RARRAY_EMBED_LEN_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray {
    pub basic: RBasic,
    pub as_: RArray__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1 {
    pub heap: RArray__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub aux: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ptr: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared_root: VALUE,
}
extern "C" {
    pub fn rb_ary_ptr_use_start(ary: VALUE) -> *mut VALUE;
}
extern "C" {
    pub fn rb_ary_ptr_use_end(a: VALUE);
}
extern "C" {
    pub fn rb_ary_detransient(a: VALUE);
}
extern "C" {
    pub fn rb_big_sign(num: VALUE) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rmodule_flags {
    RMODULE_IS_OVERLAID = 16384,
    RMODULE_IS_REFINEMENT = 32768,
    RMODULE_INCLUDED_INTO_REFINEMENT = 65536,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rb_class_get_superclass(arg1: VALUE) -> VALUE;
}
pub type RUBY_DATA_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RData {
    pub basic: RBasic,
    pub dmark: RUBY_DATA_FUNC,
    pub dfree: RUBY_DATA_FUNC,
    pub data: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn rb_data_object_wrap(
        klass: VALUE,
        datap: *mut ::std::os::raw::c_void,
        dmark: RUBY_DATA_FUNC,
        dfree: RUBY_DATA_FUNC,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_data_object_zalloc(
        klass: VALUE,
        size: size_t,
        dmark: RUBY_DATA_FUNC,
        dfree: RUBY_DATA_FUNC,
    ) -> VALUE;
}
extern "C" {
    pub static mut rb_cObject: VALUE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_io_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFile {
    pub basic: RBasic,
    pub fptr: *mut rb_io_t,
}
extern "C" {
    pub fn ruby_sysinit(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ruby_init();
}
extern "C" {
    pub fn ruby_options(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_executable_node(
        n: *mut ::std::os::raw::c_void,
        status: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_run_node(n: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_show_version();
}
extern "C" {
    pub fn ruby_show_copyright();
}
extern "C" {
    pub fn ruby_init_stack(arg1: *mut VALUE);
}
extern "C" {
    pub fn ruby_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_cleanup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_finalize();
}
extern "C" {
    pub fn ruby_stop(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ruby_stack_check() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_stack_length(arg1: *mut *mut VALUE) -> size_t;
}
extern "C" {
    pub fn ruby_exec_node(n: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_script(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ruby_set_script_name(name: VALUE);
}
extern "C" {
    pub fn ruby_prog_init();
}
extern "C" {
    pub fn ruby_set_argv(arg1: ::std::os::raw::c_int, arg2: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn ruby_process_options(
        arg1: ::std::os::raw::c_int,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_init_loadpath();
}
extern "C" {
    pub fn ruby_incpush(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ruby_sig_finalize();
}
extern "C" {
    pub fn rb_disable_super();
}
extern "C" {
    pub fn rb_enable_super();
}
extern "C" {
    pub fn rb_hash_iter_lev();
}
extern "C" {
    pub fn rb_hash_ifnone();
}
extern "C" {
    pub fn rb_str_associate();
}
extern "C" {
    pub fn rb_str_associated();
}
extern "C" {
    pub fn rb_autoload(arg1: VALUE, arg2: ID, arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_clear_cache();
}
extern "C" {
    pub fn rb_frame_pop();
}
extern "C" {
    pub fn rb_frozen_class_p(arg1: VALUE);
}
extern "C" {
    pub fn rb_exec_end_proc();
}
extern "C" {
    pub fn rb_compile_error();
}
extern "C" {
    pub fn rb_compile_error_with_enc();
}
extern "C" {
    pub fn rb_compile_error_append();
}
extern "C" {
    pub fn rb_gc_call_finalizer_at_exit();
}
extern "C" {
    pub fn rb_trap_exit();
}
extern "C" {
    pub fn rb_struct_ptr();
}
extern "C" {
    pub fn rb_clear_trace_func();
}
extern "C" {
    pub fn rb_generic_ivar_table();
}
extern "C" {
    pub fn rb_mod_const_missing(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_size_num(hash: VALUE) -> size_t;
}
extern "C" {
    pub fn rb_hash_tbl(
        arg1: VALUE,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut st_table;
}
extern "C" {
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_robject_flags {
    ROBJECT_EMBED = 8192,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_robject_consts {
    ROBJECT_EMBED_LEN_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RObject {
    pub basic: RBasic,
    pub as_: RObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RObject__bindgen_ty_1 {
    pub heap: RObject__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RObject__bindgen_ty_1__bindgen_ty_1 {
    pub numiv: u32,
    pub ivptr: *mut VALUE,
    pub iv_index_tbl: *mut st_table,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RRegexp {
    pub basic: RBasic,
    pub ptr: *mut re_pattern_buffer,
    pub src: VALUE,
    pub usecnt: ::std::os::raw::c_ulong,
}
extern "C" {
    pub fn rb_struct_size(s: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_errinfo() -> VALUE;
}
extern "C" {
    pub fn rb_set_errinfo(arg1: VALUE);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rb_warning_category_t {
    RB_WARN_CATEGORY_NONE = 0,
    RB_WARN_CATEGORY_DEPRECATED = 1,
    RB_WARN_CATEGORY_EXPERIMENTAL = 2,
    RB_WARN_CATEGORY_ALL_BITS = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rb_io_wait_readwrite {
    RB_IO_WAIT_READABLE = 0,
    RB_IO_WAIT_WRITABLE = 1,
}
extern "C" {
    pub fn rb_raise(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_fatal(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_bug(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_bug_errno(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_sys_fail(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_sys_fail_str(arg1: VALUE);
}
extern "C" {
    pub fn rb_mod_sys_fail(arg1: VALUE, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_mod_sys_fail_str(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_readwrite_sys_fail(arg1: rb_io_wait_readwrite, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_iter_break();
}
extern "C" {
    pub fn rb_iter_break_value(arg1: VALUE);
}
extern "C" {
    pub fn rb_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_notimplement();
}
extern "C" {
    pub fn rb_syserr_new(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char)
        -> VALUE;
}
extern "C" {
    pub fn rb_syserr_new_str(n: ::std::os::raw::c_int, arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_syserr_fail(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_syserr_fail_str(arg1: ::std::os::raw::c_int, arg2: VALUE);
}
extern "C" {
    pub fn rb_mod_syserr_fail(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_mod_syserr_fail_str(arg1: VALUE, arg2: ::std::os::raw::c_int, arg3: VALUE);
}
extern "C" {
    pub fn rb_readwrite_syserr_fail(
        arg1: rb_io_wait_readwrite,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_unexpected_type(arg1: VALUE, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
}
extern "C" {
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
}
extern "C" {
    pub fn rb_warning(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_category_warning(
        arg1: rb_warning_category_t,
        arg2: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn rb_compile_warning(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn rb_category_compile_warn(
        arg1: rb_warning_category_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn rb_sys_warning(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_warn(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_category_warn(arg1: rb_warning_category_t, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_compile_warn(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rbimpl_typeddata_flags {
    RUBY_TYPED_FREE_IMMEDIATELY = 1,
    RUBY_TYPED_FROZEN_SHAREABLE = 256,
    RUBY_TYPED_WB_PROTECTED = 32,
    RUBY_TYPED_PROMOTED1 = 64,
}
pub type rb_data_type_t = rb_data_type_struct;
#[repr(C)]
#[derive(Debug)]
pub struct rb_data_type_struct {
    pub wrap_struct_name: *const ::std::os::raw::c_char,
    pub function: rb_data_type_struct__bindgen_ty_1,
    pub parent: *const rb_data_type_t,
    pub data: *mut ::std::os::raw::c_void,
    pub flags: VALUE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_data_type_struct__bindgen_ty_1 {
    pub dmark: RUBY_DATA_FUNC,
    pub dfree: RUBY_DATA_FUNC,
    pub dsize:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> size_t>,
    pub dcompact: RUBY_DATA_FUNC,
    pub reserved: [*mut ::std::os::raw::c_void; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTypedData {
    pub basic: RBasic,
    pub type_: *const rb_data_type_t,
    pub typed_flag: VALUE,
    pub data: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn rb_data_typed_object_wrap(
        klass: VALUE,
        datap: *mut ::std::os::raw::c_void,
        arg1: *const rb_data_type_t,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_data_typed_object_zalloc(
        klass: VALUE,
        size: size_t,
        type_: *const rb_data_type_t,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_typeddata_inherited_p(
        child: *const rb_data_type_t,
        parent: *const rb_data_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_typeddata_is_kind_of(
        obj: VALUE,
        data_type: *const rb_data_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_check_typeddata(
        obj: VALUE,
        data_type: *const rb_data_type_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_strtoul(
        str_: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_eval_string(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_eval_string_protect(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_eval_string_wrap(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall(arg1: VALUE, arg2: ID, arg3: ::std::os::raw::c_int, ...) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv_kw(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv_public(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv_public_kw(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_passing_block(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_passing_block_kw(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_with_block(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_with_block_kw(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: VALUE,
        arg6: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_call_super(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_call_super_kw(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_current_receiver() -> VALUE;
}
extern "C" {
    pub fn rb_get_kwargs(
        keyword_hash: VALUE,
        table: *const ID,
        required: ::std::os::raw::c_int,
        optional: ::std::os::raw::c_int,
        arg1: *mut VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_extract_keywords(orighash: *mut VALUE) -> VALUE;
}
pub type rb_event_flag_t = u32;
pub type rb_event_hook_func_t = ::std::option::Option<
    unsafe extern "C" fn(evflag: rb_event_flag_t, data: VALUE, self_: VALUE, mid: ID, klass: VALUE),
>;
extern "C" {
    pub fn rb_add_event_hook(func: rb_event_hook_func_t, events: rb_event_flag_t, data: VALUE);
}
extern "C" {
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_gc_register_address(valptr: *mut VALUE);
}
extern "C" {
    pub fn rb_global_variable(arg1: *mut VALUE);
}
extern "C" {
    pub fn rb_gc_unregister_address(valptr: *mut VALUE);
}
extern "C" {
    pub fn rb_gc_register_mark_object(object: VALUE);
}
pub type ruby_glob_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: VALUE,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_glob(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: VALUE,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        arg3: VALUE,
    );
}
extern "C" {
    pub fn ruby_glob(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ruby_glob_func,
        arg4: VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_brace_glob(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ruby_glob_func,
        arg4: VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rb_mKernel: VALUE;
}
extern "C" {
    pub static mut rb_mComparable: VALUE;
}
extern "C" {
    pub static mut rb_mEnumerable: VALUE;
}
extern "C" {
    pub static mut rb_mErrno: VALUE;
}
extern "C" {
    pub static mut rb_mFileTest: VALUE;
}
extern "C" {
    pub static mut rb_mGC: VALUE;
}
extern "C" {
    pub static mut rb_mMath: VALUE;
}
extern "C" {
    pub static mut rb_mProcess: VALUE;
}
extern "C" {
    pub static mut rb_mWaitReadable: VALUE;
}
extern "C" {
    pub static mut rb_mWaitWritable: VALUE;
}
extern "C" {
    pub static mut rb_cBasicObject: VALUE;
}
extern "C" {
    pub static mut rb_cArray: VALUE;
}
extern "C" {
    pub static mut rb_cBinding: VALUE;
}
extern "C" {
    pub static mut rb_cClass: VALUE;
}
extern "C" {
    pub static mut rb_cDir: VALUE;
}
extern "C" {
    pub static mut rb_cEncoding: VALUE;
}
extern "C" {
    pub static mut rb_cEnumerator: VALUE;
}
extern "C" {
    pub static mut rb_cFalseClass: VALUE;
}
extern "C" {
    pub static mut rb_cFile: VALUE;
}
extern "C" {
    pub static mut rb_cComplex: VALUE;
}
extern "C" {
    pub static mut rb_cFloat: VALUE;
}
extern "C" {
    pub static mut rb_cHash: VALUE;
}
extern "C" {
    pub static mut rb_cIO: VALUE;
}
extern "C" {
    pub static mut rb_cInteger: VALUE;
}
extern "C" {
    pub static mut rb_cMatch: VALUE;
}
extern "C" {
    pub static mut rb_cMethod: VALUE;
}
extern "C" {
    pub static mut rb_cModule: VALUE;
}
extern "C" {
    pub static mut rb_cNameErrorMesg: VALUE;
}
extern "C" {
    pub static mut rb_cNilClass: VALUE;
}
extern "C" {
    pub static mut rb_cNumeric: VALUE;
}
extern "C" {
    pub static mut rb_cProc: VALUE;
}
extern "C" {
    pub static mut rb_cRandom: VALUE;
}
extern "C" {
    pub static mut rb_cRange: VALUE;
}
extern "C" {
    pub static mut rb_cRational: VALUE;
}
extern "C" {
    pub static mut rb_cRegexp: VALUE;
}
extern "C" {
    pub static mut rb_cStat: VALUE;
}
extern "C" {
    pub static mut rb_cString: VALUE;
}
extern "C" {
    pub static mut rb_cStruct: VALUE;
}
extern "C" {
    pub static mut rb_cSymbol: VALUE;
}
extern "C" {
    pub static mut rb_cThread: VALUE;
}
extern "C" {
    pub static mut rb_cTime: VALUE;
}
extern "C" {
    pub static mut rb_cTrueClass: VALUE;
}
extern "C" {
    pub static mut rb_cUnboundMethod: VALUE;
}
extern "C" {
    pub static mut rb_eException: VALUE;
}
extern "C" {
    pub static mut rb_eStandardError: VALUE;
}
extern "C" {
    pub static mut rb_eSystemExit: VALUE;
}
extern "C" {
    pub static mut rb_eInterrupt: VALUE;
}
extern "C" {
    pub static mut rb_eSignal: VALUE;
}
extern "C" {
    pub static mut rb_eFatal: VALUE;
}
extern "C" {
    pub static mut rb_eArgError: VALUE;
}
extern "C" {
    pub static mut rb_eEOFError: VALUE;
}
extern "C" {
    pub static mut rb_eIndexError: VALUE;
}
extern "C" {
    pub static mut rb_eStopIteration: VALUE;
}
extern "C" {
    pub static mut rb_eKeyError: VALUE;
}
extern "C" {
    pub static mut rb_eRangeError: VALUE;
}
extern "C" {
    pub static mut rb_eIOError: VALUE;
}
extern "C" {
    pub static mut rb_eRuntimeError: VALUE;
}
extern "C" {
    pub static mut rb_eFrozenError: VALUE;
}
extern "C" {
    pub static mut rb_eSecurityError: VALUE;
}
extern "C" {
    pub static mut rb_eSystemCallError: VALUE;
}
extern "C" {
    pub static mut rb_eThreadError: VALUE;
}
extern "C" {
    pub static mut rb_eTypeError: VALUE;
}
extern "C" {
    pub static mut rb_eZeroDivError: VALUE;
}
extern "C" {
    pub static mut rb_eNotImpError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMemError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMethodError: VALUE;
}
extern "C" {
    pub static mut rb_eFloatDomainError: VALUE;
}
extern "C" {
    pub static mut rb_eLocalJumpError: VALUE;
}
extern "C" {
    pub static mut rb_eSysStackError: VALUE;
}
extern "C" {
    pub static mut rb_eRegexpError: VALUE;
}
extern "C" {
    pub static mut rb_eEncodingError: VALUE;
}
extern "C" {
    pub static mut rb_eEncCompatError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMatchingPatternError: VALUE;
}
extern "C" {
    pub static mut rb_eScriptError: VALUE;
}
extern "C" {
    pub static mut rb_eNameError: VALUE;
}
extern "C" {
    pub static mut rb_eSyntaxError: VALUE;
}
extern "C" {
    pub static mut rb_eLoadError: VALUE;
}
extern "C" {
    pub static mut rb_eMathDomainError: VALUE;
}
extern "C" {
    pub static mut rb_stdin: VALUE;
}
extern "C" {
    pub static mut rb_stdout: VALUE;
}
extern "C" {
    pub static mut rb_stderr: VALUE;
}
pub type rb_block_call_func = ::std::option::Option<
    unsafe extern "C" fn(
        yielded_arg: VALUE,
        callback_arg: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        blockarg: VALUE,
    ) -> VALUE,
>;
pub type rb_block_call_func_t = rb_block_call_func;
extern "C" {
    pub fn rb_each(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield_values(n: ::std::os::raw::c_int, ...) -> VALUE;
}
extern "C" {
    pub fn rb_yield_values2(n: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield_values_kw(
        n: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_yield_splat(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield_splat_kw(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_yield_block(
        yielded_arg: VALUE,
        callback_arg: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        blockarg: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_keyword_given_p() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_block_given_p() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_need_block();
}
extern "C" {
    pub fn rb_iterate(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg2: VALUE,
        arg3: rb_block_call_func_t,
        arg4: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_block_call(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: rb_block_call_func_t,
        arg6: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_block_call_kw(
        arg1: VALUE,
        arg2: ID,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: rb_block_call_func_t,
        arg6: VALUE,
        arg7: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_rescue(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg2: VALUE,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        arg4: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_rescue2(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg2: VALUE,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        arg4: VALUE,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_vrescue2(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg2: VALUE,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        arg4: VALUE,
        arg5: *mut __va_list_tag,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_ensure(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg2: VALUE,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg4: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_catch(
        arg1: *const ::std::os::raw::c_char,
        arg2: rb_block_call_func_t,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_catch_obj(arg1: VALUE, arg2: rb_block_call_func_t, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_throw(arg1: *const ::std::os::raw::c_char, arg2: VALUE);
}
extern "C" {
    pub fn rb_throw_obj(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_alloc_tmp_buffer(
        store: *mut VALUE,
        len: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_alloc_tmp_buffer_with_count(
        store: *mut VALUE,
        len: size_t,
        count: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_free_tmp_buffer(store: *mut VALUE);
}
extern "C" {
    pub fn ruby_malloc_size_overflow(arg1: size_t, arg2: size_t);
}
extern "C" {
    pub fn rb_define_class(arg1: *const ::std::os::raw::c_char, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_define_module(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_define_class_under(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_define_module_under(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_include_module(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_extend_object(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_prepend_module(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_newobj() -> VALUE;
}
extern "C" {
    pub fn rb_newobj_of(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, type_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_class(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_copy_generic_ivar(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_mem_clear(arg1: *mut VALUE, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_assoc_new(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_array_type(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_new() -> VALUE;
}
extern "C" {
    pub fn rb_ary_new_capa(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_new_from_args(n: ::std::os::raw::c_long, ...) -> VALUE;
}
extern "C" {
    pub fn rb_ary_new_from_values(n: ::std::os::raw::c_long, elts: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_tmp_new(arg1: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_free(arg1: VALUE);
}
extern "C" {
    pub fn rb_ary_modify(arg1: VALUE);
}
extern "C" {
    pub fn rb_ary_freeze(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_shared_with_p(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_aref(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_subseq(
        arg1: VALUE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_ary_store(arg1: VALUE, arg2: ::std::os::raw::c_long, arg3: VALUE);
}
extern "C" {
    pub fn rb_ary_dup(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_to_ary(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_to_s(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_cat(arg1: VALUE, arg2: *const VALUE, arg3: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_push(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_pop(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_shift(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_unshift(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_entry(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_each(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_join(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_reverse(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_rotate(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_sort(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_sort_bang(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_delete_at(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_clear(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_assoc(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_rassoc(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_includes(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_get_values_at(
        arg1: VALUE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE,
        >,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_ary_resize(ary: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_exc_new(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exc_new_cstr(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_exc_new_str(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_loaderror(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_loaderror_with_path(path: VALUE, arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_name_error(arg1: ID, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_name_error_str(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_frozen_error_raise(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_invalid_str(arg1: *const ::std::os::raw::c_char, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_error_frozen(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_error_frozen_object(arg1: VALUE);
}
extern "C" {
    pub fn rb_error_untrusted(arg1: VALUE);
}
extern "C" {
    pub fn rb_check_frozen(arg1: VALUE);
}
extern "C" {
    pub fn rb_check_trusted(arg1: VALUE);
}
extern "C" {
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE);
}
extern "C" {
    pub fn rb_error_arity(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_st_foreach_safe(
        arg1: *mut st_table,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: st_data_t,
                arg2: st_data_t,
                arg3: st_data_t,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: st_data_t,
    );
}
extern "C" {
    pub fn rb_check_hash_type(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_foreach(
        arg1: VALUE,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> ::std::os::raw::c_int,
        >,
        arg3: VALUE,
    );
}
extern "C" {
    pub fn rb_hash(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_new() -> VALUE;
}
extern "C" {
    pub fn rb_hash_dup(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_freeze(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_lookup(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_lookup2(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_fetch(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_clear(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_delete_if(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_bulk_insert(arg1: ::std::os::raw::c_long, arg2: *const VALUE, arg3: VALUE);
}
pub type rb_hash_update_func = ::std::option::Option<
    unsafe extern "C" fn(newkey: VALUE, oldkey: VALUE, value: VALUE) -> VALUE,
>;
extern "C" {
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE, func: rb_hash_update_func) -> VALUE;
}
extern "C" {
    pub fn rb_path_check(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_env_path_tainted() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_env_clear() -> VALUE;
}
extern "C" {
    pub fn rb_hash_size(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_free(arg1: VALUE);
}
extern "C" {
    pub fn rb_block_proc() -> VALUE;
}
extern "C" {
    pub fn rb_block_lambda() -> VALUE;
}
extern "C" {
    pub fn rb_proc_new(arg1: rb_block_call_func_t, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_proc(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call_kw(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call_with_block(
        arg1: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        arg2: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call_with_block_kw(
        arg1: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        arg2: VALUE,
        arg3: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_proc_arity(arg1: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_proc_lambda_p(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_binding_new() -> VALUE;
}
extern "C" {
    pub fn rb_obj_method(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_method(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_method_call(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_method_call_kw(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
        arg4: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_method_call_with_block(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
        arg4: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_method_call_with_block_kw(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
        arg4: VALUE,
        arg5: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_method_arity(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_obj_method_arity(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_protect(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        arg2: VALUE,
        arg3: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_scan_args(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_scan_args_kw(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *const VALUE,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_scan_args_bad_format(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_scan_args_length_mismatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_sym2id(arg1: VALUE) -> ID;
}
extern "C" {
    pub fn rb_id2sym(arg1: ID) -> VALUE;
}
extern "C" {
    pub fn rb_intern(arg1: *const ::std::os::raw::c_char) -> ID;
}
extern "C" {
    pub fn rb_intern2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_long) -> ID;
}
extern "C" {
    pub fn rb_intern_str(str_: VALUE) -> ID;
}
extern "C" {
    pub fn rb_id2name(arg1: ID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_check_id(arg1: *mut VALUE) -> ID;
}
extern "C" {
    pub fn rb_to_id(arg1: VALUE) -> ID;
}
extern "C" {
    pub fn rb_id2str(arg1: ID) -> VALUE;
}
extern "C" {
    pub fn rb_sym2str(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_to_symbol(name: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_symbol(namep: *mut VALUE) -> VALUE;
}
pub type rb_gvar_getter_t =
    ::std::option::Option<unsafe extern "C" fn(id: ID, data: *mut VALUE) -> VALUE>;
pub type rb_gvar_setter_t =
    ::std::option::Option<unsafe extern "C" fn(val: VALUE, id: ID, data: *mut VALUE)>;
pub type rb_gvar_marker_t = ::std::option::Option<unsafe extern "C" fn(var: *mut VALUE)>;
extern "C" {
    pub fn rb_gvar_undef_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_undef_marker(var: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_val_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gvar_val_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_val_marker(var: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_var_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gvar_var_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_var_marker(var: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_readonly_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE);
}
extern "C" {
    pub fn rb_define_variable(arg1: *const ::std::os::raw::c_char, arg2: *mut VALUE);
}
extern "C" {
    pub fn rb_define_virtual_variable(
        arg1: *const ::std::os::raw::c_char,
        arg2: rb_gvar_getter_t,
        arg3: rb_gvar_setter_t,
    );
}
extern "C" {
    pub fn rb_define_hooked_variable(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut VALUE,
        arg3: rb_gvar_getter_t,
        arg4: rb_gvar_setter_t,
    );
}
extern "C" {
    pub fn rb_define_readonly_variable(arg1: *const ::std::os::raw::c_char, arg2: *const VALUE);
}
extern "C" {
    pub fn rb_define_const(arg1: VALUE, arg2: *const ::std::os::raw::c_char, arg3: VALUE);
}
extern "C" {
    pub fn rb_define_global_const(arg1: *const ::std::os::raw::c_char, arg2: VALUE);
}
extern "C" {
    pub fn rb_gv_set(arg1: *const ::std::os::raw::c_char, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gv_get(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_iv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_iv_set(arg1: VALUE, arg2: *const ::std::os::raw::c_char, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_get_path(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class2name(arg1: VALUE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_obj_classname(arg1: VALUE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_p(arg1: VALUE);
}
extern "C" {
    pub fn rb_equal(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_require(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_big_new(arg1: size_t, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_bigzero_p(x: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_big_clone(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_2comp(arg1: VALUE);
}
extern "C" {
    pub fn rb_big_norm(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_resize(big: VALUE, len: size_t);
}
extern "C" {
    pub fn rb_cstr_to_inum(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_to_inum(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_cstr2inum(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_str2inum(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_big2str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_big2long(arg1: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_big2ulong(arg1: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_big2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn rb_big2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rb_big_pack(
        val: VALUE,
        buf: *mut ::std::os::raw::c_ulong,
        num_longs: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn rb_big_unpack(
        buf: *mut ::std::os::raw::c_ulong,
        num_longs: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_uv_to_utf8(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_dbl2big(arg1: f64) -> VALUE;
}
extern "C" {
    pub fn rb_big2dbl(arg1: VALUE) -> f64;
}
extern "C" {
    pub fn rb_big_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_eq(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_eql(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_minus(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_mul(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_div(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_idiv(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_modulo(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_divmod(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_pow(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_and(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_or(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_xor(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_lshift(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_rshift(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_integer_pack(
        val: VALUE,
        words: *mut ::std::os::raw::c_void,
        numwords: size_t,
        wordsize: size_t,
        nails: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_integer_unpack(
        words: *const ::std::os::raw::c_void,
        numwords: size_t,
        wordsize: size_t,
        nails: size_t,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_absint_size(val: VALUE, nlz_bits_ret: *mut ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn rb_absint_numwords(
        val: VALUE,
        word_numbits: size_t,
        nlz_bits_ret: *mut size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cmpint(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cmperr(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_complex_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_new(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_new_polar(abs: VALUE, arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_polar(abs: VALUE, arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_real(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_imag(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_plus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_minus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_mul(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_div(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_uminus(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_conjugate(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_abs(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_arg(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_pow(base: VALUE, exp: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_dbl_complex_new(real: f64, imag: f64) -> VALUE;
}
extern "C" {
    pub fn rb_Complex(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_new(arg1: rb_block_call_func_t, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_new_kw(
        arg1: rb_block_call_func_t,
        arg2: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_resume(fib: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_resume_kw(
        fib: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_yield(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_yield_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_current() -> VALUE;
}
extern "C" {
    pub fn rb_fiber_alive_p(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_dir_getwd() -> VALUE;
}
extern "C" {
    pub fn rb_enum_values_pack(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_exc_raise(arg1: VALUE);
}
extern "C" {
    pub fn rb_exc_fatal(arg1: VALUE);
}
extern "C" {
    pub fn rb_f_exit(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_f_abort(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_interrupt();
}
extern "C" {
    pub fn rb_frame_this_func() -> ID;
}
extern "C" {
    pub fn rb_jump_tag(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_obj_call_init(arg1: VALUE, arg2: ::std::os::raw::c_int, arg3: *const VALUE);
}
extern "C" {
    pub fn rb_obj_call_init_kw(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *const VALUE,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_frame_callee() -> ID;
}
extern "C" {
    pub fn rb_make_exception(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_set_end_proc(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE)>,
        arg2: VALUE,
    );
}
pub type rb_enumerator_size_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_arithmetic_sequence_components_t {
    pub begin: VALUE,
    pub end: VALUE,
    pub step: VALUE,
    pub exclude_end: ::std::os::raw::c_int,
}
extern "C" {
    pub fn rb_enumeratorize(
        arg1: VALUE,
        arg2: VALUE,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enumeratorize_with_size(
        arg1: VALUE,
        arg2: VALUE,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: rb_enumerator_size_func,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enumeratorize_with_size_kw(
        arg1: VALUE,
        arg2: VALUE,
        arg3: ::std::os::raw::c_int,
        arg4: *const VALUE,
        arg5: rb_enumerator_size_func,
        arg6: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_arithmetic_sequence_extract(
        arg1: VALUE,
        arg2: *mut rb_arithmetic_sequence_components_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_arithmetic_sequence_beg_len_step(
        arg1: VALUE,
        begp: *mut ::std::os::raw::c_long,
        lenp: *mut ::std::os::raw::c_long,
        stepp: *mut ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        err: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_file_s_expand_path(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_expand_path(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_s_absolute_path(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_absolute_path(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_find_file_ext(
        arg1: *mut VALUE,
        arg2: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_find_file(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_directory_p(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_encode_ospath(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_is_absolute_path(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_memerror();
}
extern "C" {
    pub fn rb_during_gc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_gc_mark_locations(arg1: *const VALUE, arg2: *const VALUE);
}
extern "C" {
    pub fn rb_mark_tbl(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_mark_tbl_no_pin(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_mark_set(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_mark_hash(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_gc_update_tbl_refs(ptr: *mut st_table);
}
extern "C" {
    pub fn rb_gc_mark_maybe(arg1: VALUE);
}
extern "C" {
    pub fn rb_gc_mark(arg1: VALUE);
}
extern "C" {
    pub fn rb_gc_mark_movable(arg1: VALUE);
}
extern "C" {
    pub fn rb_gc_location(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gc_force_recycle(arg1: VALUE);
}
extern "C" {
    pub fn rb_gc();
}
extern "C" {
    pub fn rb_gc_copy_finalizer(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_gc_enable() -> VALUE;
}
extern "C" {
    pub fn rb_gc_disable() -> VALUE;
}
extern "C" {
    pub fn rb_gc_start() -> VALUE;
}
extern "C" {
    pub fn rb_define_finalizer(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_undefine_finalizer(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gc_count() -> size_t;
}
extern "C" {
    pub fn rb_gc_stat(arg1: VALUE) -> size_t;
}
extern "C" {
    pub fn rb_gc_latest_gc_info(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gc_adjust_memory_usage(arg1: ssize_t);
}
extern "C" {
    pub static mut rb_fs: VALUE;
}
extern "C" {
    pub static mut rb_output_fs: VALUE;
}
extern "C" {
    pub static mut rb_rs: VALUE;
}
extern "C" {
    pub static mut rb_default_rs: VALUE;
}
extern "C" {
    pub static mut rb_output_rs: VALUE;
}
extern "C" {
    pub fn rb_io_write(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_gets(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_getbyte(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_ungetc(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_ungetbyte(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_close(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_flush(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_eof(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_binmode(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_ascii8bit_binmode(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_addstr(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_printf(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_print(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_puts(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_fdopen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_io_get_io(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_file_open_str(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_gets() -> VALUE;
}
extern "C" {
    pub fn rb_write_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_write_error2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_close_before_exec(
        lowfd: ::std::os::raw::c_int,
        maxhint: ::std::os::raw::c_int,
        noclose_fds: VALUE,
    );
}
extern "C" {
    pub fn rb_pipe(pipes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_reserved_fd_p(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_dup(oldfd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_dup2(
        oldfd: ::std::os::raw::c_int,
        newfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_pipe(fildes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_fcntl_dupfd(
        fd: ::std::os::raw::c_int,
        minfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_update_max_fd(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_fd_fix_cloexec(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_load(arg1: VALUE, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_load_protect(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_provided(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_feature_provided(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_provide(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_f_require(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_require_string(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ext_ractor_safe(flag: bool);
}
extern "C" {
    pub fn rb_marshal_dump(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_marshal_load(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_marshal_define_compat(
        newclass: VALUE,
        oldclass: VALUE,
        dumper: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        loader: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
    );
}
extern "C" {
    pub fn rb_num_zerodiv();
}
extern "C" {
    pub fn rb_num_coerce_bin(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num_coerce_cmp(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num_coerce_relop(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num_coerce_bit(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num2fix(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fix2str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_dbl_cmp(arg1: f64, arg2: f64) -> VALUE;
}
extern "C" {
    pub fn rb_class_new_instance_pass_kw(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_new_instance(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_new_instance_kw(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
        arg4: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_eql(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_any_to_s(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_inspect(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_instance_of(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_kind_of(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_alloc(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_clone(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_dup(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_taint(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_tainted(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_untaint(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_untrust(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_untrusted(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_trust(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_freeze(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_frozen_p(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_id(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memory_id(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_real(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_inherited_p(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_superclass(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_convert_type(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_check_convert_type(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_check_to_integer(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_check_to_float(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_to_int(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_to_int(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Integer(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_to_float(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Float(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_String(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Array(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Hash(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_cstr_to_dbl(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rb_str_to_dbl(arg1: VALUE, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rb_id_attrset(arg1: ID) -> ID;
}
extern "C" {
    pub fn rb_is_const_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_global_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_instance_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_attrset_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_class_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_local_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_junk_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_symname_p(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_sym_interned_p(arg1: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_backref_get() -> VALUE;
}
extern "C" {
    pub fn rb_backref_set(arg1: VALUE);
}
extern "C" {
    pub fn rb_lastline_get() -> VALUE;
}
extern "C" {
    pub fn rb_lastline_set(arg1: VALUE);
}
extern "C" {
    pub fn rb_sym_all_symbols() -> VALUE;
}
extern "C" {
    pub fn rb_last_status_set(status: ::std::os::raw::c_int, pid: pid_t);
}
extern "C" {
    pub fn rb_last_status_get() -> VALUE;
}
extern "C" {
    pub fn rb_proc_exec(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_f_exec(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_waitpid(
        pid: pid_t,
        status: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn rb_syswait(pid: pid_t);
}
extern "C" {
    pub fn rb_spawn(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> pid_t;
}
extern "C" {
    pub fn rb_spawn_err(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> pid_t;
}
extern "C" {
    pub fn rb_proc_times(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
}
extern "C" {
    pub fn rb_genrand_int32() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_genrand_real() -> f64;
}
extern "C" {
    pub fn rb_reset_random_seed();
}
extern "C" {
    pub fn rb_random_bytes(rnd: VALUE, n: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_random_int(rnd: VALUE, max: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_random_int32(rnd: VALUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_random_real(rnd: VALUE) -> f64;
}
extern "C" {
    pub fn rb_random_ulong_limited(
        rnd: VALUE,
        limit: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_genrand_ulong_limited(i: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_range_new(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_range_beg_len(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_long,
        arg3: *mut ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_long,
        arg5: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_range_values(
        range: VALUE,
        begp: *mut VALUE,
        endp: *mut VALUE,
        exclp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_rational_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_rational_new(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Rational(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_rational_num(rat: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_rational_den(rat: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_flt_rationalize_with_prec(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_flt_rationalize(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memcicmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_match_busy(arg1: VALUE);
}
extern "C" {
    pub fn rb_reg_nth_defined(arg1: ::std::os::raw::c_int, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_nth_match(arg1: ::std::os::raw::c_int, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_backref_number(match_: VALUE, backref: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_reg_last_match(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match_pre(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match_post(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match_last(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_new_str(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_reg_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_reg_alloc() -> VALUE;
}
extern "C" {
    pub fn rb_reg_init_str(re: VALUE, s: VALUE, options: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match2(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_options(arg1: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rb_argv0: VALUE;
}
extern "C" {
    pub fn rb_get_argv() -> VALUE;
}
extern "C" {
    pub fn rb_load_file(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_load_file_str(arg1: VALUE) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_fdset_t {
    pub maxfd: ::std::os::raw::c_int,
    pub fdset: *mut fd_set,
}
extern "C" {
    pub fn rb_fd_init(arg1: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_term(arg1: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_zero(arg1: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_set(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_clr(arg1: ::std::os::raw::c_int, arg2: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_isset(
        arg1: ::std::os::raw::c_int,
        arg2: *const rb_fdset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_fd_copy(arg1: *mut rb_fdset_t, arg2: *const fd_set, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_fd_dup(dst: *mut rb_fdset_t, src: *const rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut rb_fdset_t,
        arg3: *mut rb_fdset_t,
        arg4: *mut rb_fdset_t,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_fd_select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut rb_fdset_t,
        arg3: *mut rb_fdset_t,
        arg4: *mut rb_fdset_t,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_f_kill(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn ruby_posix_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn ruby_signal_name(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ruby_default_signal(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_f_sprintf(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_sprintf(arg1: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_vsprintf(arg1: *const ::std::os::raw::c_char, arg2: *mut __va_list_tag) -> VALUE;
}
extern "C" {
    pub fn rb_str_catf(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_str_vcatf(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_format(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_new(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_shared(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_frozen(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_with_class(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_tainted_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_tainted_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_external_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_external_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_locale_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_locale_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_filesystem_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_filesystem_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_new(arg1: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_new2(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_tmp_new(arg1: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_usascii_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_usascii_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_utf8_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_utf8_str_new_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_usascii_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_utf8_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_to_interned_str(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_interned_str(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_interned_str_cstr(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_free(arg1: VALUE);
}
extern "C" {
    pub fn rb_str_shared_replace(arg1: VALUE, arg2: VALUE);
}
extern "C" {
    pub fn rb_str_buf_append(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_cat(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_cat_ascii(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_obj_as_string(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_string_type(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_must_asciicompat(arg1: VALUE);
}
extern "C" {
    pub fn rb_str_dup(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_resurrect(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_locktmp(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_unlocktmp(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_times(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_sublen(arg1: VALUE, arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_str_substr(
        arg1: VALUE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_subseq(
        arg1: VALUE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_subpos(
        arg1: VALUE,
        arg2: ::std::os::raw::c_long,
        arg3: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_str_modify(arg1: VALUE);
}
extern "C" {
    pub fn rb_str_modify_expand(arg1: VALUE, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_str_freeze(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_set_len(arg1: VALUE, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_str_resize(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_cat(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_cat_cstr(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_append(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memhash(
        ptr: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_long,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_start(arg1: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_uint32(arg1: st_index_t, arg2: u32) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_uint(arg1: st_index_t, arg2: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_end(arg1: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_str_hash(arg1: VALUE) -> st_index_t;
}
extern "C" {
    pub fn rb_str_hash_cmp(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_comparable(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_cmp(arg1: VALUE, arg2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_drop_bytes(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_update(
        arg1: VALUE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
        arg4: VALUE,
    );
}
extern "C" {
    pub fn rb_str_replace(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_inspect(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_dump(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_split(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_str_intern(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_sym_to_s(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_strlen(arg1: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_offset(arg1: VALUE, arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_str_capacity(arg1: VALUE) -> size_t;
}
extern "C" {
    pub fn rb_str_ellipsize(arg1: VALUE, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_scrub(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_succ(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_new(arg1: VALUE, ...) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define(arg1: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define_under(arg1: VALUE, arg2: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_struct_alloc(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_initialize(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_getmember(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_struct_s_members(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_members(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_alloc_noinit(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define_without_accessor(
        arg1: *const ::std::os::raw::c_char,
        arg2: VALUE,
        arg3: rb_alloc_func_t,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define_without_accessor_under(
        outer: VALUE,
        class_name: *const ::std::os::raw::c_char,
        super_: VALUE,
        alloc: rb_alloc_func_t,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_thread_schedule();
}
extern "C" {
    pub fn rb_thread_wait_fd(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_thread_fd_writable(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_fd_close(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_thread_alone() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_sleep(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_thread_sleep_forever();
}
extern "C" {
    pub fn rb_thread_sleep_deadly();
}
extern "C" {
    pub fn rb_thread_stop() -> VALUE;
}
extern "C" {
    pub fn rb_thread_wakeup(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_wakeup_alive(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_run(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_kill(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_create(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> VALUE,
        >,
        arg2: *mut ::std::os::raw::c_void,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_thread_wait_for(arg1: timeval);
}
extern "C" {
    pub fn rb_thread_current() -> VALUE;
}
extern "C" {
    pub fn rb_thread_main() -> VALUE;
}
extern "C" {
    pub fn rb_thread_local_aref(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_thread_local_aset(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_atfork();
}
extern "C" {
    pub fn rb_thread_atfork_before_exec();
}
extern "C" {
    pub fn rb_exec_recursive(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE,
        >,
        arg2: VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exec_recursive_paired(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE,
        >,
        arg2: VALUE,
        arg3: VALUE,
        arg4: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exec_recursive_outer(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE,
        >,
        arg2: VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exec_recursive_paired_outer(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: ::std::os::raw::c_int) -> VALUE,
        >,
        arg2: VALUE,
        arg3: VALUE,
        arg4: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_thread_check_ints();
}
extern "C" {
    pub fn rb_thread_interrupted(thval: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_mutex_new() -> VALUE;
}
extern "C" {
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_sleep(self_: VALUE, timeout: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_synchronize(
        mutex: VALUE,
        func: ::std::option::Option<unsafe extern "C" fn(arg: VALUE) -> VALUE>,
        arg: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_timespec_now(arg1: *mut timespec);
}
extern "C" {
    pub fn rb_time_new(arg1: time_t, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_time_nano_new(arg1: time_t, arg2: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_time_timespec_new(arg1: *const timespec, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_time_num_new(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_time_interval(num: VALUE) -> timeval;
}
extern "C" {
    pub fn rb_time_timeval(time: VALUE) -> timeval;
}
extern "C" {
    pub fn rb_time_timespec(time: VALUE) -> timespec;
}
extern "C" {
    pub fn rb_time_timespec_interval(num: VALUE) -> timespec;
}
extern "C" {
    pub fn rb_time_utc_offset(time: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_name(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_path(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_path_cached(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_set_class_path(arg1: VALUE, arg2: VALUE, arg3: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_set_class_path_string(arg1: VALUE, arg2: VALUE, arg3: VALUE);
}
extern "C" {
    pub fn rb_path_to_class(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_path2class(arg1: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_class_name(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_autoload_load(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_autoload_p(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_f_trace_var(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_f_untrace_var(arg1: ::std::os::raw::c_int, arg2: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_f_global_variables() -> VALUE;
}
extern "C" {
    pub fn rb_alias_variable(arg1: ID, arg2: ID);
}
extern "C" {
    pub fn rb_free_generic_ivar(arg1: VALUE);
}
extern "C" {
    pub fn rb_ivar_get(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_ivar_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ivar_defined(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_ivar_foreach(
        arg1: VALUE,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: ID, arg2: VALUE, arg3: st_data_t) -> ::std::os::raw::c_int,
        >,
        arg3: st_data_t,
    );
}
extern "C" {
    pub fn rb_ivar_count(arg1: VALUE) -> st_index_t;
}
extern "C" {
    pub fn rb_attr_get(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_obj_instance_variables(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_remove_instance_variable(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_const_at(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_mod_const_of(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_const_list(arg1: *mut ::std::os::raw::c_void) -> VALUE;
}
extern "C" {
    pub fn rb_mod_constants(arg1: ::std::os::raw::c_int, arg2: *const VALUE, arg3: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_remove_const(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_const_defined(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_const_defined_at(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_const_defined_from(arg1: VALUE, arg2: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_const_get(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_const_get_at(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_const_get_from(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_const_set(arg1: VALUE, arg2: ID, arg3: VALUE);
}
extern "C" {
    pub fn rb_const_remove(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_cvar_defined(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_cvar_set(arg1: VALUE, arg2: ID, arg3: VALUE);
}
extern "C" {
    pub fn rb_cvar_get(arg1: VALUE, arg2: ID) -> VALUE;
}
extern "C" {
    pub fn rb_cv_set(arg1: VALUE, arg2: *const ::std::os::raw::c_char, arg3: VALUE);
}
extern "C" {
    pub fn rb_cv_get(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_define_class_variable(arg1: VALUE, arg2: *const ::std::os::raw::c_char, arg3: VALUE);
}
extern "C" {
    pub fn rb_mod_class_variables(
        arg1: ::std::os::raw::c_int,
        arg2: *const VALUE,
        arg3: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_remove_cvar(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn ruby_native_thread_p() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_snprintf(
        str_: *mut ::std::os::raw::c_char,
        n: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        n: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type OnigUChar = ::std::os::raw::c_uchar;
pub type OnigCodePoint = ::std::os::raw::c_uint;
pub type OnigCtype = ::std::os::raw::c_uint;
pub type OnigDistance = size_t;
pub type OnigCaseFoldType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigCaseFoldCodeItem {
    pub byte_len: ::std::os::raw::c_int,
    pub code_len: ::std::os::raw::c_int,
    pub code: [OnigCodePoint; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigMetaCharTableType {
    pub esc: OnigCodePoint,
    pub anychar: OnigCodePoint,
    pub anytime: OnigCodePoint,
    pub zero_or_one_time: OnigCodePoint,
    pub one_or_more_time: OnigCodePoint,
    pub anychar_anytime: OnigCodePoint,
}
pub type OnigApplyAllCaseFoldFunc = ::std::option::Option<
    unsafe extern "C" fn(
        from: OnigCodePoint,
        to: *mut OnigCodePoint,
        to_len: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigEncodingTypeST {
    pub precise_mbc_enc_len: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            e: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *const ::std::os::raw::c_char,
    pub max_enc_len: ::std::os::raw::c_int,
    pub min_enc_len: ::std::os::raw::c_int,
    pub is_mbc_newline: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub mbc_to_code: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> OnigCodePoint,
    >,
    pub code_to_mbclen: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub code_to_mbc: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            buf: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub mbc_case_fold: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            pp: *mut *const OnigUChar,
            end: *const OnigUChar,
            to: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub apply_all_case_fold: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            f: OnigApplyAllCaseFoldFunc,
            arg: *mut ::std::os::raw::c_void,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_case_fold_codes_by_str: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            p: *const OnigUChar,
            end: *const OnigUChar,
            acs: *mut OnigCaseFoldCodeItem,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub property_name_to_ctype: ::std::option::Option<
        unsafe extern "C" fn(
            enc: *const OnigEncodingTypeST,
            p: *const OnigUChar,
            end: *const OnigUChar,
        ) -> ::std::os::raw::c_int,
    >,
    pub is_code_ctype: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            ctype: OnigCtype,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_ctype_code_range: ::std::option::Option<
        unsafe extern "C" fn(
            ctype: OnigCtype,
            sb_out: *mut OnigCodePoint,
            ranges: *mut *const OnigCodePoint,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub left_adjust_char_head: ::std::option::Option<
        unsafe extern "C" fn(
            start: *const OnigUChar,
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> *mut OnigUChar,
    >,
    pub is_allowed_reverse_match: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub case_map: ::std::option::Option<
        unsafe extern "C" fn(
            flagP: *mut OnigCaseFoldType,
            pp: *mut *const OnigUChar,
            end: *const OnigUChar,
            to: *mut OnigUChar,
            to_end: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub ruby_encoding_index: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
pub type OnigEncodingType = OnigEncodingTypeST;
pub type OnigEncoding = *const OnigEncodingType;
pub type OnigOptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigSyntaxType {
    pub op: ::std::os::raw::c_uint,
    pub op2: ::std::os::raw::c_uint,
    pub behavior: ::std::os::raw::c_uint,
    pub options: OnigOptionType,
    pub meta_char_table: OnigMetaCharTableType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigRepeatRange {
    pub lower: ::std::os::raw::c_int,
    pub upper: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_pattern_buffer {
    pub p: *mut ::std::os::raw::c_uchar,
    pub used: ::std::os::raw::c_uint,
    pub alloc: ::std::os::raw::c_uint,
    pub num_mem: ::std::os::raw::c_int,
    pub num_repeat: ::std::os::raw::c_int,
    pub num_null_check: ::std::os::raw::c_int,
    pub num_comb_exp_check: ::std::os::raw::c_int,
    pub num_call: ::std::os::raw::c_int,
    pub capture_history: ::std::os::raw::c_uint,
    pub bt_mem_start: ::std::os::raw::c_uint,
    pub bt_mem_end: ::std::os::raw::c_uint,
    pub stack_pop_level: ::std::os::raw::c_int,
    pub repeat_range_alloc: ::std::os::raw::c_int,
    pub options: OnigOptionType,
    pub repeat_range: *mut OnigRepeatRange,
    pub enc: OnigEncoding,
    pub syntax: *const OnigSyntaxType,
    pub name_table: *mut ::std::os::raw::c_void,
    pub case_fold_flag: OnigCaseFoldType,
    pub optimize: ::std::os::raw::c_int,
    pub threshold_len: ::std::os::raw::c_int,
    pub anchor: ::std::os::raw::c_int,
    pub anchor_dmin: OnigDistance,
    pub anchor_dmax: OnigDistance,
    pub sub_anchor: ::std::os::raw::c_int,
    pub exact: *mut ::std::os::raw::c_uchar,
    pub exact_end: *mut ::std::os::raw::c_uchar,
    pub map: [::std::os::raw::c_uchar; 256usize],
    pub int_map: *mut ::std::os::raw::c_int,
    pub int_map_backward: *mut ::std::os::raw::c_int,
    pub dmin: OnigDistance,
    pub dmax: OnigDistance,
    pub chain: *mut re_pattern_buffer,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_encoding_consts {
    RUBY_ENCODING_INLINE_MAX = 127,
    RUBY_ENCODING_SHIFT = 22,
    RUBY_ENCODING_MASK = 532676608,
    RUBY_ENCODING_MAXNAMELEN = 42,
}
impl ruby_coderange_type {
    pub const RUBY_ENC_CODERANGE_MASK: ruby_coderange_type =
        ruby_coderange_type::RUBY_ENC_CODERANGE_BROKEN;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_coderange_type {
    RUBY_ENC_CODERANGE_UNKNOWN = 0,
    RUBY_ENC_CODERANGE_7BIT = 1048576,
    RUBY_ENC_CODERANGE_VALID = 2097152,
    RUBY_ENC_CODERANGE_BROKEN = 3145728,
}
pub type rb_encoding = OnigEncodingType;
extern "C" {
    pub fn rb_char_to_option_kcode(
        c: ::std::os::raw::c_int,
        option: *mut ::std::os::raw::c_int,
        kcode: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_replicate(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_define_dummy_encoding(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_dummy_p(enc: *mut rb_encoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_to_index(enc: *mut rb_encoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_get_index(obj: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_set_index(obj: VALUE, encindex: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_enc_capable(obj: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_find_index(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_alias(
        alias: *const ::std::os::raw::c_char,
        orig: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_to_encoding_index(arg1: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_to_encoding(arg1: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_find_encoding(arg1: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_get(arg1: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_compatible(arg1: VALUE, arg2: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_check(arg1: VALUE, arg2: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_associate_index(arg1: VALUE, arg2: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_enc_associate(arg1: VALUE, arg2: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_enc_copy(dst: VALUE, src: VALUE);
}
extern "C" {
    pub fn rb_enc_str_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_new_cstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_new_static(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_interned_str(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_interned_str_cstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_reg_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
        arg4: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_sprintf(
        arg1: *mut rb_encoding,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_vsprintf(
        arg1: *mut rb_encoding,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_strlen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut rb_encoding,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_enc_nth(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
        arg4: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_obj_encoding(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_buf_cat(
        str_: VALUE,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_uint_chr(code: ::std::os::raw::c_uint, enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_external_str_new_with_enc(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        arg1: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_export_to_enc(arg1: VALUE, arg2: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_str_conv_enc(str_: VALUE, from: *mut rb_encoding, to: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_str_conv_enc_opts(
        str_: VALUE,
        from: *mut rb_encoding,
        to: *mut rb_encoding,
        ecflags: ::std::os::raw::c_int,
        ecopts: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_raise(
        arg1: *mut rb_encoding,
        arg2: VALUE,
        arg3: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn rb_enc_from_index(idx: ::std::os::raw::c_int) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_find(name: *const ::std::os::raw::c_char) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_mbclen(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_fast_mbclen(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_precise_mbclen(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_ascget(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_codepoint_len(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_enc_codepoint(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_enc_codelen(
        code: ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_code_to_mbclen(
        code: ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_casefold(
        to: *mut ::std::os::raw::c_char,
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_toupper(c: ::std::os::raw::c_int, enc: *mut rb_encoding)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_tolower(c: ::std::os::raw::c_int, enc: *mut rb_encoding)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_intern3(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
    ) -> ID;
}
extern "C" {
    pub fn rb_interned_id_p(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
    ) -> ID;
}
extern "C" {
    pub fn rb_enc_symname_p(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_symname2_p(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
        arg3: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_str_coderange(arg1: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_coderange_scan_restartable(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut rb_encoding,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_enc_str_asciionly_p(arg1: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_from_encoding(enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_enc_unicode_p(enc: *mut rb_encoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_ascii8bit_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_utf8_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_usascii_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_locale_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_filesystem_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_default_external_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_default_internal_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_ascii8bit_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_utf8_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_usascii_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_locale_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_filesystem_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_default_external() -> VALUE;
}
extern "C" {
    pub fn rb_enc_default_internal() -> VALUE;
}
extern "C" {
    pub fn rb_enc_set_default_external(encoding: VALUE);
}
extern "C" {
    pub fn rb_enc_set_default_internal(encoding: VALUE);
}
extern "C" {
    pub fn rb_locale_charmap(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_long,
        arg3: *const ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_long,
        arg5: *mut rb_encoding,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_enc_path_next(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_path_skip_prefix(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_path_last_separator(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_path_end(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ruby_enc_find_basename(
        name: *const ::std::os::raw::c_char,
        baselen: *mut ::std::os::raw::c_long,
        alllen: *mut ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ruby_enc_find_extname(
        name: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_check_id_cstr(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> ID;
}
extern "C" {
    pub fn rb_check_symbol_cstr(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rb_econv_result_t {
    econv_invalid_byte_sequence = 0,
    econv_undefined_conversion = 1,
    econv_destination_buffer_full = 2,
    econv_source_buffer_empty = 3,
    econv_finished = 4,
    econv_after_output = 5,
    econv_incomplete_input = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_econv_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rb_str_encode(
        str_: VALUE,
        to: VALUE,
        ecflags: ::std::os::raw::c_int,
        ecopts: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_has_convpath_p(
        from_encoding: *const ::std::os::raw::c_char,
        to_encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_prepare_options(
        opthash: VALUE,
        ecopts: *mut VALUE,
        ecflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_prepare_opts(opthash: VALUE, ecopts: *mut VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_open(
        source_encoding: *const ::std::os::raw::c_char,
        destination_encoding: *const ::std::os::raw::c_char,
        ecflags: ::std::os::raw::c_int,
    ) -> *mut rb_econv_t;
}
extern "C" {
    pub fn rb_econv_open_opts(
        source_encoding: *const ::std::os::raw::c_char,
        destination_encoding: *const ::std::os::raw::c_char,
        ecflags: ::std::os::raw::c_int,
        ecopts: VALUE,
    ) -> *mut rb_econv_t;
}
extern "C" {
    pub fn rb_econv_convert(
        ec: *mut rb_econv_t,
        source_buffer_ptr: *mut *const ::std::os::raw::c_uchar,
        source_buffer_end: *const ::std::os::raw::c_uchar,
        destination_buffer_ptr: *mut *mut ::std::os::raw::c_uchar,
        destination_buffer_end: *mut ::std::os::raw::c_uchar,
        flags: ::std::os::raw::c_int,
    ) -> rb_econv_result_t;
}
extern "C" {
    pub fn rb_econv_close(ec: *mut rb_econv_t);
}
extern "C" {
    pub fn rb_econv_set_replacement(
        ec: *mut rb_econv_t,
        str_: *const ::std::os::raw::c_uchar,
        len: size_t,
        encname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_decorate_at_first(
        ec: *mut rb_econv_t,
        decorator_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_decorate_at_last(
        ec: *mut rb_econv_t,
        decorator_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_open_exc(
        senc: *const ::std::os::raw::c_char,
        denc: *const ::std::os::raw::c_char,
        ecflags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_insert_output(
        ec: *mut rb_econv_t,
        str_: *const ::std::os::raw::c_uchar,
        len: size_t,
        str_encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_encoding_to_insert_output(ec: *mut rb_econv_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_econv_check_error(ec: *mut rb_econv_t);
}
extern "C" {
    pub fn rb_econv_make_exception(ec: *mut rb_econv_t) -> VALUE;
}
extern "C" {
    pub fn rb_econv_putbackable(ec: *mut rb_econv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_putback(
        ec: *mut rb_econv_t,
        p: *mut ::std::os::raw::c_uchar,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_econv_asciicompat_encoding(
        encname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_econv_str_convert(
        ec: *mut rb_econv_t,
        src: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_substr_convert(
        ec: *mut rb_econv_t,
        src: VALUE,
        byteoff: ::std::os::raw::c_long,
        bytesize: ::std::os::raw::c_long,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_str_append(
        ec: *mut rb_econv_t,
        src: VALUE,
        dst: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_substr_append(
        ec: *mut rb_econv_t,
        src: VALUE,
        byteoff: ::std::os::raw::c_long,
        bytesize: ::std::os::raw::c_long,
        dst: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_append(
        ec: *mut rb_econv_t,
        bytesrc: *const ::std::os::raw::c_char,
        bytesize: ::std::os::raw::c_long,
        dst: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_binmode(ec: *mut rb_econv_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_econv_flag_type {
    RUBY_ECONV_ERROR_HANDLER_MASK = 255,
    RUBY_ECONV_INVALID_MASK = 15,
    RUBY_ECONV_INVALID_REPLACE = 2,
    RUBY_ECONV_UNDEF_MASK = 240,
    RUBY_ECONV_UNDEF_REPLACE = 32,
    RUBY_ECONV_UNDEF_HEX_CHARREF = 48,
    RUBY_ECONV_DECORATOR_MASK = 65280,
    RUBY_ECONV_NEWLINE_DECORATOR_MASK = 16128,
    RUBY_ECONV_NEWLINE_DECORATOR_READ_MASK = 3840,
    RUBY_ECONV_NEWLINE_DECORATOR_WRITE_MASK = 12288,
    RUBY_ECONV_UNIVERSAL_NEWLINE_DECORATOR = 256,
    RUBY_ECONV_CRLF_NEWLINE_DECORATOR = 4096,
    RUBY_ECONV_CR_NEWLINE_DECORATOR = 8192,
    RUBY_ECONV_XML_TEXT_DECORATOR = 16384,
    RUBY_ECONV_XML_ATTR_CONTENT_DECORATOR = 32768,
    RUBY_ECONV_STATEFUL_DECORATOR_MASK = 15728640,
    RUBY_ECONV_XML_ATTR_QUOTE_DECORATOR = 1048576,
    RUBY_ECONV_DEFAULT_NEWLINE_DECORATOR = 0,
    RUBY_ECONV_PARTIAL_INPUT = 65536,
    RUBY_ECONV_AFTER_OUTPUT = 131072,
    RUBY_ECONV_FLAGS_PLACEHOLDER = 131073,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
